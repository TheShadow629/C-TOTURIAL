0
<font color="#FFFFFF" size="16">今天我们来讲一个经典的字符串匹配算法</font>
<font color="#FFFFFF" size="16">km p字符串匹配呢是一个非常基本的操作</font>
00:00:09,850 --> 00:00:12,710
<font color="#FFFFFF" size="16">也就在一个字符串中寻找另一个子串</font>
00:00:12,710 --> 00:00:15,860
<font color="#FFFFFF" size="16">其中最容易想到的是一种暴力匹配的算法</font>
00:00:15,860 --> 00:00:18,750
<font color="#FFFFFF" size="16">比如一个字一个字地与子串进行比对</font>
00:00:18,750 --> 00:00:19,950
<font color="#FFFFFF" size="16">一旦匹配失败</font>
00:00:19,950 --> 00:00:22,020
<font color="#FFFFFF" size="16">就跳回主唱中的下一个字符</font>
00:00:22,020 --> 00:00:23,500
<font color="#FFFFFF" size="16">重新开始匹配</font>
00:00:23,500 --> 00:00:25,180
<font color="#FFFFFF" size="16">这个算法的原理很简单</font>
00:00:25,180 --> 00:00:26,770
<font color="#FFFFFF" size="16">实现起来也十分容易</font>
00:00:26,770 --> 00:00:29,470
<font color="#FFFFFF" size="16">但最大的问题在于它的时间复杂度</font>
00:00:29,470 --> 00:00:30,790
<font color="#FFFFFF" size="16">假如你运气不好</font>
00:00:30,790 --> 00:00:33,610
<font color="#FFFFFF" size="16">恰好碰到主串和子串都是若干个a</font>
00:00:33,610 --> 00:00:35,380
<font color="#FFFFFF" size="16">最后紧跟一个b的情况</font>
00:00:35,380 --> 00:00:37,300
<font color="#FFFFFF" size="16">这个时候呢算法会很傻的</font>
00:00:37,300 --> 00:00:38,950
<font color="#FFFFFF" size="16">把前面的a都比对完</font>
00:00:38,950 --> 00:00:41,140
<font color="#FFFFFF" size="16">然后发现最后一个字符不匹配</font>
00:00:41,140 --> 00:00:43,420
<font color="#FFFFFF" size="16">于是跳回下一个字符重新比对</font>
00:00:43,420 --> 00:00:45,180
<font color="#FFFFFF" size="16">做了不少的无用功</font>
00:00:45,280 --> 00:00:46,180
<font color="#FFFFFF" size="16">不难发现</font>
00:00:46,180 --> 00:00:48,970
<font color="#FFFFFF" size="16">这是一个o n乘以m时间复杂度的算法</font>
00:00:48,970 --> 00:00:50,470
<font color="#FFFFFF" size="16">因此效率极低</font>
00:00:50,470 --> 00:00:52,810
<font color="#FFFFFF" size="16">这个时候呢有三位大佬k mp</font>
00:00:52,810 --> 00:00:53,629
<font color="#FFFFFF" size="16">他们就想</font>
00:00:53,629 --> 00:00:55,909
<font color="#FFFFFF" size="16">既然字符串在比对失败的时候</font>
00:00:55,909 --> 00:00:58,789
<font color="#FFFFFF" size="16">我们已经知道之前都读过哪些字符了</font>
00:00:58,789 --> 00:01:02,980
<font color="#FFFFFF" size="16">有没有可能避免跳回下一个字符再重新匹配的步骤呢</font>
00:01:02,980 --> 00:01:06,460
<font color="#FFFFFF" size="16">于是他们就发表了线性时间复杂度的k mp算法</font>
00:01:06,460 --> 00:01:07,390
<font color="#FFFFFF" size="16">换句话说</font>
00:01:07,390 --> 00:01:11,780
<font color="#FFFFFF" size="16">你只需要在一次字符串便利的过程中就可以匹配出子串</font>
00:01:11,780 --> 00:01:14,060
<font color="#FFFFFF" size="16">当然我在第一次学习这个算法的时候</font>
00:01:14,060 --> 00:01:15,200
<font color="#FFFFFF" size="16">是一脸懵逼的</font>
00:01:15,200 --> 00:01:16,970
<font color="#FFFFFF" size="16">被很多概念搞得一头雾水</font>
00:01:16,970 --> 00:01:18,930
<font color="#FFFFFF" size="16">却不知道为什么要这样设计</font>
00:01:18,930 --> 00:01:22,950
<font color="#FFFFFF" size="16">所以今天我想用一种更直观的方式跟大家学习交流一下</font>
00:01:22,950 --> 00:01:24,960
<font color="#FFFFFF" size="16">kp算法的工作原理</font>
00:01:37,380 --> 00:01:42,230
<font color="#FFFFFF" size="16">kp算法的基本思路是当我们发现某一个字符不匹配的时候</font>
00:01:42,230 --> 00:01:44,620
<font color="#FFFFFF" size="16">由于已经知道之前编辑过的字符</font>
00:01:44,620 --> 00:01:49,110
<font color="#FFFFFF" size="16">那能不能利用这些信息来避免暴力算法中回退的步骤呢</font>
00:01:49,110 --> 00:01:50,010
<font color="#FFFFFF" size="16">换句话说</font>
00:01:50,010 --> 00:01:52,410
<font color="#FFFFFF" size="16">我们不希望递减上面的这个指针</font>
00:01:52,410 --> 00:01:54,520
<font color="#FFFFFF" size="16">而让它永远向前方移动</font>
00:01:54,520 --> 00:01:55,900
<font color="#FFFFFF" size="16">如果能做到这一点</font>
00:01:55,900 --> 00:01:59,580
<font color="#FFFFFF" size="16">我们的算法不就可以改进为线性时间复杂度了吗</font>
00:01:59,640 --> 00:02:01,080
<font color="#FFFFFF" size="16">给大家举个例子</font>
00:02:01,080 --> 00:02:04,320
<font color="#FFFFFF" size="16">这里我们在主串中搜索a b a b c</font>
00:02:04,320 --> 00:02:06,720
<font color="#FFFFFF" size="16">然后发现最后一个字符不匹配</font>
00:02:06,720 --> 00:02:10,840
<font color="#FFFFFF" size="16">这个时候由于我们已经知道前面都读到过哪些字符</font>
00:02:10,840 --> 00:02:13,360
<font color="#FFFFFF" size="16">是不是可以将子串移动到这个位置</font>
00:02:13,360 --> 00:02:14,980
<font color="#FFFFFF" size="16">接着进行匹配呢</font>
00:02:15,019 --> 00:02:18,649
<font color="#FFFFFF" size="16">由于这里的a b和主串中的ab是相同的</font>
00:02:18,649 --> 00:02:20,179
<font color="#FFFFFF" size="16">我们完全可以跳过它们</font>
00:02:20,179 --> 00:02:21,600
<font color="#FFFFFF" size="16">避免重复的比对</font>
00:02:21,600 --> 00:02:24,980
<font color="#FFFFFF" size="16">接下来只需要继续测试后面的字符就好了</font>
00:02:25,119 --> 00:02:29,120
<font color="#FFFFFF" size="16">那你可能会问我们怎么知道应该跳过多少个字符呢</font>
00:02:29,120 --> 00:02:32,360
<font color="#FFFFFF" size="16">这里就要用到camp中定义的next数组了</font>
00:02:32,360 --> 00:02:35,240
<font color="#FFFFFF" size="16">我们先不管next数组是怎样生成的</font>
00:02:35,240 --> 00:02:37,620
<font color="#FFFFFF" size="16">先来看一下它的功能和用途</font>
00:02:37,780 --> 00:02:40,330
<font color="#FFFFFF" size="16">kp算法在匹配失败的时候</font>
00:02:40,330 --> 00:02:42,460
<font color="#FFFFFF" size="16">会去看最后一个匹配的字符</font>
00:02:42,460 --> 00:02:44,410
<font color="#FFFFFF" size="16">它所对应的next数值</font>
00:02:44,410 --> 00:02:45,660
<font color="#FFFFFF" size="16">比如这里是二</font>
00:02:45,660 --> 00:02:49,500
<font color="#FFFFFF" size="16">于是我们移动子串直接跳过前面的这两个字符</font>
00:02:49,500 --> 00:02:54,070
<font color="#FFFFFF" size="16">这里的二代表子串中我们可以跳过匹配的字符个数</font>
00:02:54,070 --> 00:02:57,070
<font color="#FFFFFF" size="16">也就是说前面的这两个ab不需要看了</font>
00:02:57,070 --> 00:02:59,340
<font color="#FFFFFF" size="16">直接从下一个字符接着匹配</font>
00:02:59,340 --> 00:03:01,260
<font color="#FFFFFF" size="16">很显然这样是没有问题的</font>
00:03:01,260 --> 00:03:05,610
<font color="#FFFFFF" size="16">因为跳过的这两个a b确实能够与主串中的ab匹配上</font>
00:03:05,610 --> 00:03:08,740
<font color="#FFFFFF" size="16">所以我们只需要继续测试后面的字符就好了</font>
00:03:08,880 --> 00:03:11,730
<font color="#FFFFFF" size="16">由于不再需要回退主串中的指针</font>
00:03:11,730 --> 00:03:14,670
<font color="#FFFFFF" size="16">只需要一次主串的便利就可以完成匹配</font>
00:03:14,670 --> 00:03:17,580
<font color="#FFFFFF" size="16">效率自然会比之前的暴力算法高很多</font>
00:03:17,820 --> 00:03:22,020
<font color="#FFFFFF" size="16">那么接下来呢我们来看一下kp算法的程序实现</font>
00:03:22,020 --> 00:03:25,830
<font color="#FFFFFF" size="16">不过这里假设我们已经事先得出了next数组</font>
00:03:25,830 --> 00:03:27,210
<font color="#FFFFFF" size="16">关于数组的计算</font>
00:03:27,210 --> 00:03:28,580
<font color="#FFFFFF" size="16">我们马上讲到</font>
00:03:28,640 --> 00:03:30,950
<font color="#FFFFFF" size="16">首先我们逐个字符的比较</font>
00:03:30,950 --> 00:03:32,660
<font color="#FFFFFF" size="16">如果当前字符相同</font>
00:03:32,660 --> 00:03:36,640
<font color="#FFFFFF" size="16">则同时递增i j这两个指针如果不相同</font>
00:03:36,640 --> 00:03:40,720
<font color="#FFFFFF" size="16">则根据next数值跳过子串前几个字符的比较</font>
00:03:40,720 --> 00:03:41,620
<font color="#FFFFFF" size="16">需要注意的是</font>
00:03:41,620 --> 00:03:43,510
<font color="#FFFFFF" size="16">这里的i永远不递减</font>
00:03:43,510 --> 00:03:45,750
<font color="#FFFFFF" size="16">这也是kp算法的精髓</font>
00:03:45,750 --> 00:03:48,780
<font color="#FFFFFF" size="16">如果指针j已经到达了子串的末尾</font>
00:03:48,780 --> 00:03:50,340
<font color="#FFFFFF" size="16">则代表匹配成功</font>
00:03:50,340 --> 00:03:53,350
<font color="#FFFFFF" size="16">我们直接返回匹配的起始位置即可</font>
00:03:53,350 --> 00:03:55,930
<font color="#FFFFFF" size="16">这里程序的逻辑还是比较简单的</font>
00:03:55,930 --> 00:03:57,490
<font color="#FFFFFF" size="16">时间复杂度为o n</font>
00:03:57,490 --> 00:04:00,620
<font color="#FFFFFF" size="16">大家可以结合下面的动画加深理解一下</font>
00:04:19,680 --> 00:04:24,080
<font color="#FFFFFF" size="16">那么接下来要解决的关键问题就是next数组的生成了</font>
00:04:24,080 --> 00:04:28,370
<font color="#FFFFFF" size="16">之前我们讲到next的数值代表了在匹配失败的时候</font>
00:04:28,370 --> 00:04:31,430
<font color="#FFFFFF" size="16">子串中可以跳过匹配的字符个数</font>
00:04:31,430 --> 00:04:35,240
<font color="#FFFFFF" size="16">如果是二就代表我们可以跳过前两个字符的比较</font>
00:04:35,240 --> 00:04:37,130
<font color="#FFFFFF" size="16">但凭什么可以这么做呢</font>
00:04:37,130 --> 00:04:40,520
<font color="#FFFFFF" size="16">因为我们之前成功匹配的最后这两个ab</font>
00:04:40,520 --> 00:04:44,340
<font color="#FFFFFF" size="16">和这里跳过的最前面的这两个ab是完全一样的</font>
00:04:44,340 --> 00:04:45,270
<font color="#FFFFFF" size="16">换句话说</font>
00:04:45,270 --> 00:04:47,220
<font color="#FFFFFF" size="16">对于子串的前四个字符</font>
00:04:47,220 --> 00:04:49,500
<font color="#FFFFFF" size="16">它们拥有一个共同的前缀和后缀</font>
00:04:49,500 --> 00:04:51,440
<font color="#FFFFFF" size="16">ab长度为二</font>
00:04:51,580 --> 00:04:53,110
<font color="#FFFFFF" size="16">所以大家发现没有</font>
00:04:53,110 --> 00:04:58,060
<font color="#FFFFFF" size="16">next数组的本质其实就是寻找子串中相同前后缀的长度</font>
00:04:58,060 --> 00:05:02,750
<font color="#FFFFFF" size="16">并且一定是最长的前后缀与这里的aa虽然也相同</font>
00:05:02,750 --> 00:05:04,400
<font color="#FFFFFF" size="16">但它并不是最长的</font>
00:05:04,400 --> 00:05:08,040
<font color="#FFFFFF" size="16">这里还有个更长的a b a因此next为三</font>
00:05:08,140 --> 00:05:11,410
<font color="#FFFFFF" size="16">另外我们要找的前后缀不能是字符串本身</font>
00:05:11,410 --> 00:05:13,480
<font color="#FFFFFF" size="16">比如我们总共就四个字符</font>
00:05:13,480 --> 00:05:15,640
<font color="#FFFFFF" size="16">如果还跳过前四个字符的比较</font>
00:05:15,640 --> 00:05:17,260
<font color="#FFFFFF" size="16">那请问还有意义吗</font>
00:05:17,980 --> 00:05:22,900
<font color="#FFFFFF" size="16">下面我们还是以a b a b c为例来说明一下next数组的计算</font>
00:05:22,900 --> 00:05:26,800
<font color="#FFFFFF" size="16">首先对第一个字符显然不存在比它短的前后缀</font>
00:05:26,800 --> 00:05:28,820
<font color="#FFFFFF" size="16">所以next直接为零</font>
00:05:28,820 --> 00:05:32,480
<font color="#FFFFFF" size="16">接着对于前两个字符同样没有相同的前后缀</font>
00:05:32,480 --> 00:05:33,960
<font color="#FFFFFF" size="16">所以max为零</font>
00:05:33,960 --> 00:05:35,340
<font color="#FFFFFF" size="16">对于前三个字符</font>
00:05:35,340 --> 00:05:37,260
<font color="#FFFFFF" size="16">由于a是共同的前后缀</font>
00:05:37,260 --> 00:05:38,900
<font color="#FFFFFF" size="16">所以next为一</font>
00:05:38,900 --> 00:05:40,340
<font color="#FFFFFF" size="16">对于前四个字符</font>
00:05:40,340 --> 00:05:42,260
<font color="#FFFFFF" size="16">由于ab是共同的前后缀</font>
00:05:42,260 --> 00:05:43,370
<font color="#FFFFFF" size="16">next为二</font>
00:05:43,370 --> 00:05:46,640
<font color="#FFFFFF" size="16">对于前五个字符同样找不到相同的前后缀</font>
00:05:46,640 --> 00:05:48,120
<font color="#FFFFFF" size="16">所以next为零</font>
00:05:48,120 --> 00:05:51,140
<font color="#FFFFFF" size="16">这样我们就计算得到了整个next数组</font>
00:05:51,140 --> 00:05:53,030
<font color="#FFFFFF" size="16">但算法应该怎么写呢</font>
00:05:53,030 --> 00:05:55,310
<font color="#FFFFFF" size="16">我们当然可以用for循环暴力求解</font>
00:05:55,310 --> 00:05:56,909
<font color="#FFFFFF" size="16">但显然效率太低</font>
00:05:56,909 --> 00:06:01,890
<font color="#FFFFFF" size="16">其实这里呢可以采用一种递推的方式来快速求解next数组</font>
00:06:01,890 --> 00:06:07,380
<font color="#FFFFFF" size="16">它的巧妙之处在于会不断的利用已经掌握的信息来避免重复的运算</font>
00:06:07,500 --> 00:06:10,560
<font color="#FFFFFF" size="16">假设我们已经知道当前的共同前后缀了</font>
00:06:10,560 --> 00:06:11,710
<font color="#FFFFFF" size="16">长度为二</font>
00:06:11,710 --> 00:06:13,870
<font color="#FFFFFF" size="16">接下来分两种情况讨论</font>
00:06:13,870 --> 00:06:16,300
<font color="#FFFFFF" size="16">如果下一个字符依然相同的话</font>
00:06:16,300 --> 00:06:18,880
<font color="#FFFFFF" size="16">不就直接构成了一个更长的前后缀吗</font>
00:06:18,880 --> 00:06:21,780
<font color="#FFFFFF" size="16">很明显它的长度等于之前的加上一</font>
00:06:21,880 --> 00:06:23,980
<font color="#FFFFFF" size="16">但如果下个字符不同的话</font>
00:06:23,980 --> 00:06:25,520
<font color="#FFFFFF" size="16">又应该怎么办呢</font>
00:06:25,599 --> 00:06:29,229
<font color="#FFFFFF" size="16">既然a b a无法与下一个字符构成更长的前后缀</font>
00:06:29,229 --> 00:06:31,899
<font color="#FFFFFF" size="16">我们就看看其中存不存在更短的</font>
00:06:31,899 --> 00:06:36,670
<font color="#FFFFFF" size="16">比如这里的a他其实是有可能与下一个字符构成共同前后缀的</font>
00:06:36,670 --> 00:06:38,710
<font color="#FFFFFF" size="16">这一步难道要暴力求解吗</font>
00:06:38,710 --> 00:06:39,810
<font color="#FFFFFF" size="16">其实不然</font>
00:06:39,810 --> 00:06:41,220
<font color="#FFFFFF" size="16">根据之前的计算</font>
00:06:41,220 --> 00:06:42,930
<font color="#FFFFFF" size="16">我们掌握了一个重要信息</font>
00:06:42,930 --> 00:06:47,050
<font color="#FFFFFF" size="16">那就是子串前后的这两部分是完全相同的</font>
00:06:47,050 --> 00:06:51,800
<font color="#FFFFFF" size="16">也就是说右边这部分的后缀其实等同于左边这部分的后缀</font>
00:06:51,800 --> 00:06:55,630
<font color="#FFFFFF" size="16">那我们直接在左边寻找共同的前后缀不就好了吗</font>
00:06:55,630 --> 00:06:58,570
<font color="#FFFFFF" size="16">而左边的前后缀我们之前已经计算过了</font>
00:06:58,570 --> 00:07:01,430
<font color="#FFFFFF" size="16">直接查表就可以得到它的长度是一</font>
00:07:01,430 --> 00:07:03,860
<font color="#FFFFFF" size="16">于是我们又回到了最开始的步骤</font>
00:07:03,860 --> 00:07:05,990
<font color="#FFFFFF" size="16">检查下一个字符是否相同</font>
00:07:05,990 --> 00:07:06,950
<font color="#FFFFFF" size="16">如果相同</font>
00:07:06,950 --> 00:07:08,960
<font color="#FFFFFF" size="16">则可以构成一个更长的前后缀</font>
00:07:08,960 --> 00:07:10,500
<font color="#FFFFFF" size="16">长度加一即可</font>
00:07:10,500 --> 00:07:15,440
<font color="#FFFFFF" size="16">我们可以结合下面的动画来加深理解一下数组的整个计算过程</font>
00:07:36,480 --> 00:07:38,390
<font color="#FFFFFF" size="16">在掌握了算法的原理之后</font>
00:07:38,390 --> 00:07:40,549
<font color="#FFFFFF" size="16">代码的实现就很简单了</font>
00:07:40,549 --> 00:07:41,629
<font color="#FFFFFF" size="16">和之前一样</font>
00:07:41,629 --> 00:07:44,179
<font color="#FFFFFF" size="16">我们依次生成每一个next的数值</font>
00:07:44,179 --> 00:07:46,470
<font color="#FFFFFF" size="16">不过这里需要注意一下初始值</font>
00:07:46,470 --> 00:07:48,660
<font color="#FFFFFF" size="16">如果下一个字符依然相同的话</font>
00:07:48,660 --> 00:07:51,000
<font color="#FFFFFF" size="16">代表可以构成一个更长的前后缀</font>
00:07:51,000 --> 00:07:52,580
<font color="#FFFFFF" size="16">长度加一即可</font>
00:07:52,740 --> 00:07:54,810
<font color="#FFFFFF" size="16">如果下一个字符不同的话</font>
00:07:54,810 --> 00:07:56,010
<font color="#FFFFFF" size="16">我们直接查表</font>
00:07:56,010 --> 00:07:58,860
<font color="#FFFFFF" size="16">看看其中存不存在更短的前后缀</font>
00:07:58,860 --> 00:08:00,510
<font color="#FFFFFF" size="16">如果依然不存在的话</font>
00:08:00,510 --> 00:08:02,620
<font color="#FFFFFF" size="16">那么将next设为零即可</font>
00:08:03,840 --> 00:08:07,530
<font color="#FFFFFF" size="16">到这里呢我们就讲完了kp算法的全部内容</font>
00:08:07,530 --> 00:08:10,920
<font color="#FFFFFF" size="16">不得不说next数组的计算确实比较绕</font>
00:08:10,920 --> 00:08:15,530
<font color="#FFFFFF" size="16">但它的本质不过是通过已经掌握的信息来规避重复的运算</font>
00:08:15,530 --> 00:08:18,580
<font color="#FFFFFF" size="16">这个动态规划的思想是非常像的</font>
00:08:18,620 --> 00:08:21,770
<font color="#FFFFFF" size="16">也希望这些视频能够解答大家心中的疑惑</font>
00:08:21,770 --> 00:08:23,760
<font color="#FFFFFF" size="16">或者给大家提供一些思路</font>
00:08:23,760 --> 00:08:25,350
<font color="#FFFFFF" size="16">最后感谢大家观看</font>
